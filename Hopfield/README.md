Вот README для вашего нового файла `HopfieldNN.ipynb`.

---

# Проект: Нейронная сеть Хопфилда

Данный проект реализует нейронную сеть Хопфилда, предназначенную для хранения и восстановления ассоциативных паттернов. Проект представлен в виде Jupyter Notebook — `Hopfield_NN.ipynb`, в котором описана реализация модели, обучение и демонстрация работы сети на примере сохранения и восстановления бинарных изображений.

## Содержание

- [Технологии](#технологии)
- [Установка](#установка)
- [Описание модели](#описание-модели)
- [Пример использования](#пример-использования)
- [Результаты](#результаты)

## Технологии

В проекте используются следующие технологии и библиотеки:
- Python
- NumPy
- Matplotlib (для визуализации результатов)

## Установка

1. Клонируйте репозиторий:
   ```bash
   git clone https://github.com/lepy0ha/NN/Hopfield.git
   ```
2. Установите необходимые зависимости:
   ```bash
   pip install -r requirements.txt
   ```

## Описание модели

Модель представляет собой нейронную сеть Хопфилда, которая используется для ассоциативного запоминания. Основные этапы работы включают:
- **Создание весовой матрицы**: сеть запоминает паттерны путём настройки весов между нейронами.
- **Обучение и восстановление**: сеть обучается на заданных паттернах и впоследствии способна восстанавливать оригинальные паттерны при искажённом входе.

### Архитектура модели
Сеть Хопфилда представляет собой полностью связанный двоичный граф, в котором каждый узел связан с каждым другим. При обучении модель использует правило Хебба для сохранения заданных паттернов.

## Пример использования

В файле `Hopfield_NN.ipynb` содержится руководство по обучению сети Хопфилда и восстановлению искажённых паттернов, включающее:
1. Инициализацию сети и обучение на выбранных паттернах.
2. Восстановление оригинального изображения из искажённого входа.
3. Визуализацию результатов работы модели.

Для запуска примера используйте следующий код в ноутбуке:
```python
from Hopfield_NN import HopfieldNN

# Инициализация и запуск обучения
network = HopfieldNN()
network.train(patterns)
recovered_pattern = network.recall(distorted_pattern)
```

